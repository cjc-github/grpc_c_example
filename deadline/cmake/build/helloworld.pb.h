// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: helloworld.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_helloworld_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_helloworld_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_helloworld_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_helloworld_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_helloworld_2eproto;
namespace helloworld {
class ComputeNode;
struct ComputeNodeDefaultTypeInternal;
extern ComputeNodeDefaultTypeInternal _ComputeNode_default_instance_;
class Fuzzer;
struct FuzzerDefaultTypeInternal;
extern FuzzerDefaultTypeInternal _Fuzzer_default_instance_;
class GetCoverageRequest;
struct GetCoverageRequestDefaultTypeInternal;
extern GetCoverageRequestDefaultTypeInternal _GetCoverageRequest_default_instance_;
class GetCoverageResponse;
struct GetCoverageResponseDefaultTypeInternal;
extern GetCoverageResponseDefaultTypeInternal _GetCoverageResponse_default_instance_;
class GetSeedsRequest;
struct GetSeedsRequestDefaultTypeInternal;
extern GetSeedsRequestDefaultTypeInternal _GetSeedsRequest_default_instance_;
class GetSeedsResponse;
struct GetSeedsResponseDefaultTypeInternal;
extern GetSeedsResponseDefaultTypeInternal _GetSeedsResponse_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class HelloReply;
struct HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class PutCoverageRequest;
struct PutCoverageRequestDefaultTypeInternal;
extern PutCoverageRequestDefaultTypeInternal _PutCoverageRequest_default_instance_;
class PutCoverageResponse;
struct PutCoverageResponseDefaultTypeInternal;
extern PutCoverageResponseDefaultTypeInternal _PutCoverageResponse_default_instance_;
class PutSeedRequest;
struct PutSeedRequestDefaultTypeInternal;
extern PutSeedRequestDefaultTypeInternal _PutSeedRequest_default_instance_;
class PutSeedResponse;
struct PutSeedResponseDefaultTypeInternal;
extern PutSeedResponseDefaultTypeInternal _PutSeedResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class Seed;
struct SeedDefaultTypeInternal;
extern SeedDefaultTypeInternal _Seed_default_instance_;
class UnregisterRequest;
struct UnregisterRequestDefaultTypeInternal;
extern UnregisterRequestDefaultTypeInternal _UnregisterRequest_default_instance_;
class UnregisterResponse;
struct UnregisterResponseDefaultTypeInternal;
extern UnregisterResponseDefaultTypeInternal _UnregisterResponse_default_instance_;
}  // namespace helloworld
PROTOBUF_NAMESPACE_OPEN
template <>
::helloworld::ComputeNode* Arena::CreateMaybeMessage<::helloworld::ComputeNode>(Arena*);
template <>
::helloworld::Fuzzer* Arena::CreateMaybeMessage<::helloworld::Fuzzer>(Arena*);
template <>
::helloworld::GetCoverageRequest* Arena::CreateMaybeMessage<::helloworld::GetCoverageRequest>(Arena*);
template <>
::helloworld::GetCoverageResponse* Arena::CreateMaybeMessage<::helloworld::GetCoverageResponse>(Arena*);
template <>
::helloworld::GetSeedsRequest* Arena::CreateMaybeMessage<::helloworld::GetSeedsRequest>(Arena*);
template <>
::helloworld::GetSeedsResponse* Arena::CreateMaybeMessage<::helloworld::GetSeedsResponse>(Arena*);
template <>
::helloworld::HeartbeatRequest* Arena::CreateMaybeMessage<::helloworld::HeartbeatRequest>(Arena*);
template <>
::helloworld::HeartbeatResponse* Arena::CreateMaybeMessage<::helloworld::HeartbeatResponse>(Arena*);
template <>
::helloworld::HelloReply* Arena::CreateMaybeMessage<::helloworld::HelloReply>(Arena*);
template <>
::helloworld::HelloRequest* Arena::CreateMaybeMessage<::helloworld::HelloRequest>(Arena*);
template <>
::helloworld::PutCoverageRequest* Arena::CreateMaybeMessage<::helloworld::PutCoverageRequest>(Arena*);
template <>
::helloworld::PutCoverageResponse* Arena::CreateMaybeMessage<::helloworld::PutCoverageResponse>(Arena*);
template <>
::helloworld::PutSeedRequest* Arena::CreateMaybeMessage<::helloworld::PutSeedRequest>(Arena*);
template <>
::helloworld::PutSeedResponse* Arena::CreateMaybeMessage<::helloworld::PutSeedResponse>(Arena*);
template <>
::helloworld::RegisterRequest* Arena::CreateMaybeMessage<::helloworld::RegisterRequest>(Arena*);
template <>
::helloworld::RegisterResponse* Arena::CreateMaybeMessage<::helloworld::RegisterResponse>(Arena*);
template <>
::helloworld::Seed* Arena::CreateMaybeMessage<::helloworld::Seed>(Arena*);
template <>
::helloworld::UnregisterRequest* Arena::CreateMaybeMessage<::helloworld::UnregisterRequest>(Arena*);
template <>
::helloworld::UnregisterResponse* Arena::CreateMaybeMessage<::helloworld::UnregisterResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace helloworld {
enum SeedType : int {
  NORMAL = 0,
  NEW = 1,
  CRASH = 2,
  HANG = 3,
  SeedType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SeedType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SeedType_IsValid(int value);
constexpr SeedType SeedType_MIN = static_cast<SeedType>(0);
constexpr SeedType SeedType_MAX = static_cast<SeedType>(3);
constexpr int SeedType_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SeedType_descriptor();
template <typename T>
const std::string& SeedType_Name(T value) {
  static_assert(std::is_same<T, SeedType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SeedType_Name().");
  return SeedType_Name(static_cast<SeedType>(value));
}
template <>
inline const std::string& SeedType_Name(SeedType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SeedType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SeedType_Parse(absl::string_view name, SeedType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeedType>(
      SeedType_descriptor(), name, value);
}
enum FuzzerType : int {
  FUZZER_UNKNOWN = 0,
  FUZZER_AFL = 1,
  FUZZER_ANGORA = 2,
  FUZZER_QSYM = 3,
  FUZZER_LIBFUZZER = 4,
  FUZZER_HONGGFUZZ = 5,
  FUZZER_AFLFAST = 6,
  FUZZER_FAIRFUZZ = 7,
  FUZZER_RADAMSA = 8,
  FuzzerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FuzzerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FuzzerType_IsValid(int value);
constexpr FuzzerType FuzzerType_MIN = static_cast<FuzzerType>(0);
constexpr FuzzerType FuzzerType_MAX = static_cast<FuzzerType>(8);
constexpr int FuzzerType_ARRAYSIZE = 8 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
FuzzerType_descriptor();
template <typename T>
const std::string& FuzzerType_Name(T value) {
  static_assert(std::is_same<T, FuzzerType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FuzzerType_Name().");
  return FuzzerType_Name(static_cast<FuzzerType>(value));
}
template <>
inline const std::string& FuzzerType_Name(FuzzerType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<FuzzerType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool FuzzerType_Parse(absl::string_view name, FuzzerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FuzzerType>(
      FuzzerType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class HelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloRequest& from) {
    HelloRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:helloworld.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class HelloReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.HelloReply) */ {
 public:
  inline HelloReply() : HelloReply(nullptr) {}
  ~HelloReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HelloReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloReply(const HelloReply& from);
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloReply& from) {
    HelloReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.HelloReply";
  }
  protected:
  explicit HelloReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:helloworld.HelloReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class Fuzzer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.Fuzzer) */ {
 public:
  inline Fuzzer() : Fuzzer(nullptr) {}
  ~Fuzzer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Fuzzer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fuzzer(const Fuzzer& from);
  Fuzzer(Fuzzer&& from) noexcept
    : Fuzzer() {
    *this = ::std::move(from);
  }

  inline Fuzzer& operator=(const Fuzzer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fuzzer& operator=(Fuzzer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fuzzer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fuzzer* internal_default_instance() {
    return reinterpret_cast<const Fuzzer*>(
               &_Fuzzer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Fuzzer& a, Fuzzer& b) {
    a.Swap(&b);
  }
  inline void Swap(Fuzzer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fuzzer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fuzzer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fuzzer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fuzzer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fuzzer& from) {
    Fuzzer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fuzzer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.Fuzzer";
  }
  protected:
  explicit Fuzzer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kExecFieldNumber = 3,
    kBitmapSizeFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kComputeNodeIdFieldNumber = 6,
    kFuzzerTypeFieldNumber = 2,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 exec = 3;
  void clear_exec() ;
  ::uint64_t exec() const;
  void set_exec(::uint64_t value);

  private:
  ::uint64_t _internal_exec() const;
  void _internal_set_exec(::uint64_t value);

  public:
  // uint64 bitmap_size = 4;
  void clear_bitmap_size() ;
  ::uint64_t bitmap_size() const;
  void set_bitmap_size(::uint64_t value);

  private:
  ::uint64_t _internal_bitmap_size() const;
  void _internal_set_bitmap_size(::uint64_t value);

  public:
  // uint64 timestamp = 5;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint64 compute_node_id = 6;
  void clear_compute_node_id() ;
  ::uint64_t compute_node_id() const;
  void set_compute_node_id(::uint64_t value);

  private:
  ::uint64_t _internal_compute_node_id() const;
  void _internal_set_compute_node_id(::uint64_t value);

  public:
  // .helloworld.FuzzerType fuzzer_type = 2;
  void clear_fuzzer_type() ;
  ::helloworld::FuzzerType fuzzer_type() const;
  void set_fuzzer_type(::helloworld::FuzzerType value);

  private:
  ::helloworld::FuzzerType _internal_fuzzer_type() const;
  void _internal_set_fuzzer_type(::helloworld::FuzzerType value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.Fuzzer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t id_;
    ::uint64_t exec_;
    ::uint64_t bitmap_size_;
    ::uint64_t timestamp_;
    ::uint64_t compute_node_id_;
    int fuzzer_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class ComputeNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.ComputeNode) */ {
 public:
  inline ComputeNode() : ComputeNode(nullptr) {}
  ~ComputeNode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ComputeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputeNode(const ComputeNode& from);
  ComputeNode(ComputeNode&& from) noexcept
    : ComputeNode() {
    *this = ::std::move(from);
  }

  inline ComputeNode& operator=(const ComputeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputeNode& operator=(ComputeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComputeNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputeNode* internal_default_instance() {
    return reinterpret_cast<const ComputeNode*>(
               &_ComputeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ComputeNode& a, ComputeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputeNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputeNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComputeNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ComputeNode& from) {
    ComputeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.ComputeNode";
  }
  protected:
  explicit ComputeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpaddrFieldNumber = 2,
    kIdFieldNumber = 1,
    kMemSizeFieldNumber = 4,
    kCoresFieldNumber = 3,
  };
  // string ipaddr = 2;
  void clear_ipaddr() ;
  const std::string& ipaddr() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ipaddr(Arg_&& arg, Args_... args);
  std::string* mutable_ipaddr();
  PROTOBUF_NODISCARD std::string* release_ipaddr();
  void set_allocated_ipaddr(std::string* ptr);

  private:
  const std::string& _internal_ipaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipaddr(
      const std::string& value);
  std::string* _internal_mutable_ipaddr();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 mem_size = 4;
  void clear_mem_size() ;
  ::uint64_t mem_size() const;
  void set_mem_size(::uint64_t value);

  private:
  ::uint64_t _internal_mem_size() const;
  void _internal_set_mem_size(::uint64_t value);

  public:
  // uint32 cores = 3;
  void clear_cores() ;
  ::uint32_t cores() const;
  void set_cores(::uint32_t value);

  private:
  ::uint32_t _internal_cores() const;
  void _internal_set_cores(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.ComputeNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddr_;
    ::uint64_t id_;
    ::uint64_t mem_size_;
    ::uint32_t cores_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class Seed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.Seed) */ {
 public:
  inline Seed() : Seed(nullptr) {}
  ~Seed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Seed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Seed(const Seed& from);
  Seed(Seed&& from) noexcept
    : Seed() {
    *this = ::std::move(from);
  }

  inline Seed& operator=(const Seed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Seed& operator=(Seed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Seed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Seed* internal_default_instance() {
    return reinterpret_cast<const Seed*>(
               &_Seed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Seed& a, Seed& b) {
    a.Swap(&b);
  }
  inline void Swap(Seed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Seed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Seed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Seed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Seed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Seed& from) {
    Seed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Seed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.Seed";
  }
  protected:
  explicit Seed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 5,
    kDataFieldNumber = 6,
    kIdFieldNumber = 1,
    kLengthFieldNumber = 3,
    kFuzzerIdFieldNumber = 4,
    kSeedTypeFieldNumber = 2,
  };
  // string file_path = 5;
  void clear_file_path() ;
  const std::string& file_path() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_path(Arg_&& arg, Args_... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* ptr);

  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(
      const std::string& value);
  std::string* _internal_mutable_file_path();

  public:
  // bytes data = 6;
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 length = 3;
  void clear_length() ;
  ::uint64_t length() const;
  void set_length(::uint64_t value);

  private:
  ::uint64_t _internal_length() const;
  void _internal_set_length(::uint64_t value);

  public:
  // uint64 fuzzer_id = 4;
  void clear_fuzzer_id() ;
  ::uint64_t fuzzer_id() const;
  void set_fuzzer_id(::uint64_t value);

  private:
  ::uint64_t _internal_fuzzer_id() const;
  void _internal_set_fuzzer_id(::uint64_t value);

  public:
  // .helloworld.SeedType seed_type = 2;
  void clear_seed_type() ;
  ::helloworld::SeedType seed_type() const;
  void set_seed_type(::helloworld::SeedType value);

  private:
  ::helloworld::SeedType _internal_seed_type() const;
  void _internal_set_seed_type(::helloworld::SeedType value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.Seed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::uint64_t id_;
    ::uint64_t length_;
    ::uint64_t fuzzer_id_;
    int seed_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuzzerFieldNumber = 1,
    kComputeNodeFieldNumber = 2,
  };
  // .helloworld.Fuzzer fuzzer = 1;
  bool has_fuzzer() const;
  void clear_fuzzer() ;
  const ::helloworld::Fuzzer& fuzzer() const;
  PROTOBUF_NODISCARD ::helloworld::Fuzzer* release_fuzzer();
  ::helloworld::Fuzzer* mutable_fuzzer();
  void set_allocated_fuzzer(::helloworld::Fuzzer* fuzzer);
  private:
  const ::helloworld::Fuzzer& _internal_fuzzer() const;
  ::helloworld::Fuzzer* _internal_mutable_fuzzer();
  public:
  void unsafe_arena_set_allocated_fuzzer(
      ::helloworld::Fuzzer* fuzzer);
  ::helloworld::Fuzzer* unsafe_arena_release_fuzzer();
  // .helloworld.ComputeNode compute_node = 2;
  bool has_compute_node() const;
  void clear_compute_node() ;
  const ::helloworld::ComputeNode& compute_node() const;
  PROTOBUF_NODISCARD ::helloworld::ComputeNode* release_compute_node();
  ::helloworld::ComputeNode* mutable_compute_node();
  void set_allocated_compute_node(::helloworld::ComputeNode* compute_node);
  private:
  const ::helloworld::ComputeNode& _internal_compute_node() const;
  ::helloworld::ComputeNode* _internal_mutable_compute_node();
  public:
  void unsafe_arena_set_allocated_compute_node(
      ::helloworld::ComputeNode* compute_node);
  ::helloworld::ComputeNode* unsafe_arena_release_compute_node();
  // @@protoc_insertion_point(class_scope:helloworld.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::helloworld::Fuzzer* fuzzer_;
    ::helloworld::ComputeNode* compute_node_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterResponse& from) {
    RegisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuzzerIdFieldNumber = 2,
    kComputeNodeIdFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // uint64 fuzzer_id = 2;
  void clear_fuzzer_id() ;
  ::uint64_t fuzzer_id() const;
  void set_fuzzer_id(::uint64_t value);

  private:
  ::uint64_t _internal_fuzzer_id() const;
  void _internal_set_fuzzer_id(::uint64_t value);

  public:
  // uint64 compute_node_id = 3;
  void clear_compute_node_id() ;
  ::uint64_t compute_node_id() const;
  void set_compute_node_id(::uint64_t value);

  private:
  ::uint64_t _internal_compute_node_id() const;
  void _internal_set_compute_node_id(::uint64_t value);

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.RegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t fuzzer_id_;
    ::uint64_t compute_node_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class UnregisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.UnregisterRequest) */ {
 public:
  inline UnregisterRequest() : UnregisterRequest(nullptr) {}
  ~UnregisterRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnregisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnregisterRequest(const UnregisterRequest& from);
  UnregisterRequest(UnregisterRequest&& from) noexcept
    : UnregisterRequest() {
    *this = ::std::move(from);
  }

  inline UnregisterRequest& operator=(const UnregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnregisterRequest& operator=(UnregisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnregisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnregisterRequest* internal_default_instance() {
    return reinterpret_cast<const UnregisterRequest*>(
               &_UnregisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnregisterRequest& a, UnregisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnregisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnregisterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnregisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnregisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnregisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnregisterRequest& from) {
    UnregisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnregisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.UnregisterRequest";
  }
  protected:
  explicit UnregisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuzzerIdFieldNumber = 1,
  };
  // uint64 fuzzer_id = 1;
  void clear_fuzzer_id() ;
  ::uint64_t fuzzer_id() const;
  void set_fuzzer_id(::uint64_t value);

  private:
  ::uint64_t _internal_fuzzer_id() const;
  void _internal_set_fuzzer_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.UnregisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t fuzzer_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class UnregisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.UnregisterResponse) */ {
 public:
  inline UnregisterResponse() : UnregisterResponse(nullptr) {}
  ~UnregisterResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnregisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnregisterResponse(const UnregisterResponse& from);
  UnregisterResponse(UnregisterResponse&& from) noexcept
    : UnregisterResponse() {
    *this = ::std::move(from);
  }

  inline UnregisterResponse& operator=(const UnregisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnregisterResponse& operator=(UnregisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnregisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnregisterResponse* internal_default_instance() {
    return reinterpret_cast<const UnregisterResponse*>(
               &_UnregisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UnregisterResponse& a, UnregisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnregisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnregisterResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnregisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnregisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnregisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnregisterResponse& from) {
    UnregisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnregisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.UnregisterResponse";
  }
  protected:
  explicit UnregisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.UnregisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatRequest& from) {
    HeartbeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuzzerIdFieldNumber = 1,
    kExecFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // uint64 fuzzer_id = 1;
  void clear_fuzzer_id() ;
  ::uint64_t fuzzer_id() const;
  void set_fuzzer_id(::uint64_t value);

  private:
  ::uint64_t _internal_fuzzer_id() const;
  void _internal_set_fuzzer_id(::uint64_t value);

  public:
  // uint64 exec = 2;
  void clear_exec() ;
  ::uint64_t exec() const;
  void set_exec(::uint64_t value);

  private:
  ::uint64_t _internal_exec() const;
  void _internal_set_exec(::uint64_t value);

  public:
  // uint64 timestamp = 3;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t fuzzer_id_;
    ::uint64_t exec_;
    ::uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class HeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatResponse& from) {
    HeartbeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class GetSeedsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.GetSeedsRequest) */ {
 public:
  inline GetSeedsRequest() : GetSeedsRequest(nullptr) {}
  ~GetSeedsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetSeedsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSeedsRequest(const GetSeedsRequest& from);
  GetSeedsRequest(GetSeedsRequest&& from) noexcept
    : GetSeedsRequest() {
    *this = ::std::move(from);
  }

  inline GetSeedsRequest& operator=(const GetSeedsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSeedsRequest& operator=(GetSeedsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSeedsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSeedsRequest* internal_default_instance() {
    return reinterpret_cast<const GetSeedsRequest*>(
               &_GetSeedsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetSeedsRequest& a, GetSeedsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSeedsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSeedsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSeedsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSeedsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSeedsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSeedsRequest& from) {
    GetSeedsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSeedsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.GetSeedsRequest";
  }
  protected:
  explicit GetSeedsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuzzerIdFieldNumber = 1,
  };
  // uint64 fuzzer_id = 1;
  void clear_fuzzer_id() ;
  ::uint64_t fuzzer_id() const;
  void set_fuzzer_id(::uint64_t value);

  private:
  ::uint64_t _internal_fuzzer_id() const;
  void _internal_set_fuzzer_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.GetSeedsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t fuzzer_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class GetSeedsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.GetSeedsResponse) */ {
 public:
  inline GetSeedsResponse() : GetSeedsResponse(nullptr) {}
  ~GetSeedsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetSeedsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSeedsResponse(const GetSeedsResponse& from);
  GetSeedsResponse(GetSeedsResponse&& from) noexcept
    : GetSeedsResponse() {
    *this = ::std::move(from);
  }

  inline GetSeedsResponse& operator=(const GetSeedsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSeedsResponse& operator=(GetSeedsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSeedsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSeedsResponse* internal_default_instance() {
    return reinterpret_cast<const GetSeedsResponse*>(
               &_GetSeedsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetSeedsResponse& a, GetSeedsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSeedsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSeedsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSeedsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSeedsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSeedsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSeedsResponse& from) {
    GetSeedsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSeedsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.GetSeedsResponse";
  }
  protected:
  explicit GetSeedsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedsFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .helloworld.Seed seeds = 2;
  int seeds_size() const;
  private:
  int _internal_seeds_size() const;

  public:
  void clear_seeds() ;
  ::helloworld::Seed* mutable_seeds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::helloworld::Seed >*
      mutable_seeds();
  private:
  const ::helloworld::Seed& _internal_seeds(int index) const;
  ::helloworld::Seed* _internal_add_seeds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::helloworld::Seed>& _internal_seeds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::helloworld::Seed>* _internal_mutable_seeds();
  public:
  const ::helloworld::Seed& seeds(int index) const;
  ::helloworld::Seed* add_seeds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::helloworld::Seed >&
      seeds() const;
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.GetSeedsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::helloworld::Seed > seeds_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class PutSeedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.PutSeedRequest) */ {
 public:
  inline PutSeedRequest() : PutSeedRequest(nullptr) {}
  ~PutSeedRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PutSeedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutSeedRequest(const PutSeedRequest& from);
  PutSeedRequest(PutSeedRequest&& from) noexcept
    : PutSeedRequest() {
    *this = ::std::move(from);
  }

  inline PutSeedRequest& operator=(const PutSeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutSeedRequest& operator=(PutSeedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutSeedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutSeedRequest* internal_default_instance() {
    return reinterpret_cast<const PutSeedRequest*>(
               &_PutSeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PutSeedRequest& a, PutSeedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutSeedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutSeedRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutSeedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutSeedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutSeedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutSeedRequest& from) {
    PutSeedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutSeedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.PutSeedRequest";
  }
  protected:
  explicit PutSeedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedFieldNumber = 2,
    kFuzzerIdFieldNumber = 1,
  };
  // .helloworld.Seed seed = 2;
  bool has_seed() const;
  void clear_seed() ;
  const ::helloworld::Seed& seed() const;
  PROTOBUF_NODISCARD ::helloworld::Seed* release_seed();
  ::helloworld::Seed* mutable_seed();
  void set_allocated_seed(::helloworld::Seed* seed);
  private:
  const ::helloworld::Seed& _internal_seed() const;
  ::helloworld::Seed* _internal_mutable_seed();
  public:
  void unsafe_arena_set_allocated_seed(
      ::helloworld::Seed* seed);
  ::helloworld::Seed* unsafe_arena_release_seed();
  // uint64 fuzzer_id = 1;
  void clear_fuzzer_id() ;
  ::uint64_t fuzzer_id() const;
  void set_fuzzer_id(::uint64_t value);

  private:
  ::uint64_t _internal_fuzzer_id() const;
  void _internal_set_fuzzer_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.PutSeedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::helloworld::Seed* seed_;
    ::uint64_t fuzzer_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class PutSeedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.PutSeedResponse) */ {
 public:
  inline PutSeedResponse() : PutSeedResponse(nullptr) {}
  ~PutSeedResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PutSeedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutSeedResponse(const PutSeedResponse& from);
  PutSeedResponse(PutSeedResponse&& from) noexcept
    : PutSeedResponse() {
    *this = ::std::move(from);
  }

  inline PutSeedResponse& operator=(const PutSeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutSeedResponse& operator=(PutSeedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutSeedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutSeedResponse* internal_default_instance() {
    return reinterpret_cast<const PutSeedResponse*>(
               &_PutSeedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PutSeedResponse& a, PutSeedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutSeedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutSeedResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutSeedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutSeedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutSeedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutSeedResponse& from) {
    PutSeedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutSeedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.PutSeedResponse";
  }
  protected:
  explicit PutSeedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.PutSeedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class PutCoverageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.PutCoverageRequest) */ {
 public:
  inline PutCoverageRequest() : PutCoverageRequest(nullptr) {}
  ~PutCoverageRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PutCoverageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutCoverageRequest(const PutCoverageRequest& from);
  PutCoverageRequest(PutCoverageRequest&& from) noexcept
    : PutCoverageRequest() {
    *this = ::std::move(from);
  }

  inline PutCoverageRequest& operator=(const PutCoverageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutCoverageRequest& operator=(PutCoverageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutCoverageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutCoverageRequest* internal_default_instance() {
    return reinterpret_cast<const PutCoverageRequest*>(
               &_PutCoverageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PutCoverageRequest& a, PutCoverageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutCoverageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutCoverageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutCoverageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutCoverageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutCoverageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutCoverageRequest& from) {
    PutCoverageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutCoverageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.PutCoverageRequest";
  }
  protected:
  explicit PutCoverageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoverageDataFieldNumber = 2,
    kFuzzerIdFieldNumber = 1,
  };
  // bytes coverage_data = 2;
  void clear_coverage_data() ;
  const std::string& coverage_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_coverage_data(Arg_&& arg, Args_... args);
  std::string* mutable_coverage_data();
  PROTOBUF_NODISCARD std::string* release_coverage_data();
  void set_allocated_coverage_data(std::string* ptr);

  private:
  const std::string& _internal_coverage_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coverage_data(
      const std::string& value);
  std::string* _internal_mutable_coverage_data();

  public:
  // uint64 fuzzer_id = 1;
  void clear_fuzzer_id() ;
  ::uint64_t fuzzer_id() const;
  void set_fuzzer_id(::uint64_t value);

  private:
  ::uint64_t _internal_fuzzer_id() const;
  void _internal_set_fuzzer_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.PutCoverageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coverage_data_;
    ::uint64_t fuzzer_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class PutCoverageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.PutCoverageResponse) */ {
 public:
  inline PutCoverageResponse() : PutCoverageResponse(nullptr) {}
  ~PutCoverageResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PutCoverageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutCoverageResponse(const PutCoverageResponse& from);
  PutCoverageResponse(PutCoverageResponse&& from) noexcept
    : PutCoverageResponse() {
    *this = ::std::move(from);
  }

  inline PutCoverageResponse& operator=(const PutCoverageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutCoverageResponse& operator=(PutCoverageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutCoverageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutCoverageResponse* internal_default_instance() {
    return reinterpret_cast<const PutCoverageResponse*>(
               &_PutCoverageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PutCoverageResponse& a, PutCoverageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutCoverageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutCoverageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutCoverageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutCoverageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutCoverageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutCoverageResponse& from) {
    PutCoverageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutCoverageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.PutCoverageResponse";
  }
  protected:
  explicit PutCoverageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.PutCoverageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class GetCoverageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.GetCoverageRequest) */ {
 public:
  inline GetCoverageRequest() : GetCoverageRequest(nullptr) {}
  ~GetCoverageRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCoverageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCoverageRequest(const GetCoverageRequest& from);
  GetCoverageRequest(GetCoverageRequest&& from) noexcept
    : GetCoverageRequest() {
    *this = ::std::move(from);
  }

  inline GetCoverageRequest& operator=(const GetCoverageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCoverageRequest& operator=(GetCoverageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCoverageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCoverageRequest* internal_default_instance() {
    return reinterpret_cast<const GetCoverageRequest*>(
               &_GetCoverageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetCoverageRequest& a, GetCoverageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCoverageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCoverageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCoverageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCoverageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCoverageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCoverageRequest& from) {
    GetCoverageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCoverageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.GetCoverageRequest";
  }
  protected:
  explicit GetCoverageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuzzerIdFieldNumber = 1,
  };
  // uint64 fuzzer_id = 1;
  void clear_fuzzer_id() ;
  ::uint64_t fuzzer_id() const;
  void set_fuzzer_id(::uint64_t value);

  private:
  ::uint64_t _internal_fuzzer_id() const;
  void _internal_set_fuzzer_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.GetCoverageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t fuzzer_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};// -------------------------------------------------------------------

class GetCoverageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:helloworld.GetCoverageResponse) */ {
 public:
  inline GetCoverageResponse() : GetCoverageResponse(nullptr) {}
  ~GetCoverageResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCoverageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCoverageResponse(const GetCoverageResponse& from);
  GetCoverageResponse(GetCoverageResponse&& from) noexcept
    : GetCoverageResponse() {
    *this = ::std::move(from);
  }

  inline GetCoverageResponse& operator=(const GetCoverageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCoverageResponse& operator=(GetCoverageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCoverageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCoverageResponse* internal_default_instance() {
    return reinterpret_cast<const GetCoverageResponse*>(
               &_GetCoverageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetCoverageResponse& a, GetCoverageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCoverageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCoverageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCoverageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCoverageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCoverageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCoverageResponse& from) {
    GetCoverageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCoverageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "helloworld.GetCoverageResponse";
  }
  protected:
  explicit GetCoverageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoverageDataFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // bytes coverage_data = 2;
  void clear_coverage_data() ;
  const std::string& coverage_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_coverage_data(Arg_&& arg, Args_... args);
  std::string* mutable_coverage_data();
  PROTOBUF_NODISCARD std::string* release_coverage_data();
  void set_allocated_coverage_data(std::string* ptr);

  private:
  const std::string& _internal_coverage_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coverage_data(
      const std::string& value);
  std::string* _internal_mutable_coverage_data();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:helloworld.GetCoverageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coverage_data_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helloworld_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:helloworld.HelloRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HelloRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:helloworld.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:helloworld.HelloRequest.name)
  return _s;
}
inline const std::string& HelloRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:helloworld.HelloRequest.name)
  return _impl_.name_.Release();
}
inline void HelloRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:helloworld.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:helloworld.HelloReply.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HelloReply::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:helloworld.HelloReply.message)
}
inline std::string* HelloReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:helloworld.HelloReply.message)
  return _s;
}
inline const std::string& HelloReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HelloReply::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloReply::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:helloworld.HelloReply.message)
  return _impl_.message_.Release();
}
inline void HelloReply::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:helloworld.HelloReply.message)
}

// -------------------------------------------------------------------

// Fuzzer

// uint64 id = 1;
inline void Fuzzer::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Fuzzer::id() const {
  // @@protoc_insertion_point(field_get:helloworld.Fuzzer.id)
  return _internal_id();
}
inline void Fuzzer::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:helloworld.Fuzzer.id)
}
inline ::uint64_t Fuzzer::_internal_id() const {
  return _impl_.id_;
}
inline void Fuzzer::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// .helloworld.FuzzerType fuzzer_type = 2;
inline void Fuzzer::clear_fuzzer_type() {
  _impl_.fuzzer_type_ = 0;
}
inline ::helloworld::FuzzerType Fuzzer::fuzzer_type() const {
  // @@protoc_insertion_point(field_get:helloworld.Fuzzer.fuzzer_type)
  return _internal_fuzzer_type();
}
inline void Fuzzer::set_fuzzer_type(::helloworld::FuzzerType value) {
   _internal_set_fuzzer_type(value);
  // @@protoc_insertion_point(field_set:helloworld.Fuzzer.fuzzer_type)
}
inline ::helloworld::FuzzerType Fuzzer::_internal_fuzzer_type() const {
  return static_cast<::helloworld::FuzzerType>(_impl_.fuzzer_type_);
}
inline void Fuzzer::_internal_set_fuzzer_type(::helloworld::FuzzerType value) {
  ;
  _impl_.fuzzer_type_ = value;
}

// uint64 exec = 3;
inline void Fuzzer::clear_exec() {
  _impl_.exec_ = ::uint64_t{0u};
}
inline ::uint64_t Fuzzer::exec() const {
  // @@protoc_insertion_point(field_get:helloworld.Fuzzer.exec)
  return _internal_exec();
}
inline void Fuzzer::set_exec(::uint64_t value) {
  _internal_set_exec(value);
  // @@protoc_insertion_point(field_set:helloworld.Fuzzer.exec)
}
inline ::uint64_t Fuzzer::_internal_exec() const {
  return _impl_.exec_;
}
inline void Fuzzer::_internal_set_exec(::uint64_t value) {
  ;
  _impl_.exec_ = value;
}

// uint64 bitmap_size = 4;
inline void Fuzzer::clear_bitmap_size() {
  _impl_.bitmap_size_ = ::uint64_t{0u};
}
inline ::uint64_t Fuzzer::bitmap_size() const {
  // @@protoc_insertion_point(field_get:helloworld.Fuzzer.bitmap_size)
  return _internal_bitmap_size();
}
inline void Fuzzer::set_bitmap_size(::uint64_t value) {
  _internal_set_bitmap_size(value);
  // @@protoc_insertion_point(field_set:helloworld.Fuzzer.bitmap_size)
}
inline ::uint64_t Fuzzer::_internal_bitmap_size() const {
  return _impl_.bitmap_size_;
}
inline void Fuzzer::_internal_set_bitmap_size(::uint64_t value) {
  ;
  _impl_.bitmap_size_ = value;
}

// uint64 timestamp = 5;
inline void Fuzzer::clear_timestamp() {
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t Fuzzer::timestamp() const {
  // @@protoc_insertion_point(field_get:helloworld.Fuzzer.timestamp)
  return _internal_timestamp();
}
inline void Fuzzer::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:helloworld.Fuzzer.timestamp)
}
inline ::uint64_t Fuzzer::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void Fuzzer::_internal_set_timestamp(::uint64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// uint64 compute_node_id = 6;
inline void Fuzzer::clear_compute_node_id() {
  _impl_.compute_node_id_ = ::uint64_t{0u};
}
inline ::uint64_t Fuzzer::compute_node_id() const {
  // @@protoc_insertion_point(field_get:helloworld.Fuzzer.compute_node_id)
  return _internal_compute_node_id();
}
inline void Fuzzer::set_compute_node_id(::uint64_t value) {
  _internal_set_compute_node_id(value);
  // @@protoc_insertion_point(field_set:helloworld.Fuzzer.compute_node_id)
}
inline ::uint64_t Fuzzer::_internal_compute_node_id() const {
  return _impl_.compute_node_id_;
}
inline void Fuzzer::_internal_set_compute_node_id(::uint64_t value) {
  ;
  _impl_.compute_node_id_ = value;
}

// -------------------------------------------------------------------

// ComputeNode

// uint64 id = 1;
inline void ComputeNode::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t ComputeNode::id() const {
  // @@protoc_insertion_point(field_get:helloworld.ComputeNode.id)
  return _internal_id();
}
inline void ComputeNode::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:helloworld.ComputeNode.id)
}
inline ::uint64_t ComputeNode::_internal_id() const {
  return _impl_.id_;
}
inline void ComputeNode::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// string ipaddr = 2;
inline void ComputeNode::clear_ipaddr() {
  _impl_.ipaddr_.ClearToEmpty();
}
inline const std::string& ComputeNode::ipaddr() const {
  // @@protoc_insertion_point(field_get:helloworld.ComputeNode.ipaddr)
  return _internal_ipaddr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ComputeNode::set_ipaddr(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ipaddr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:helloworld.ComputeNode.ipaddr)
}
inline std::string* ComputeNode::mutable_ipaddr() {
  std::string* _s = _internal_mutable_ipaddr();
  // @@protoc_insertion_point(field_mutable:helloworld.ComputeNode.ipaddr)
  return _s;
}
inline const std::string& ComputeNode::_internal_ipaddr() const {
  return _impl_.ipaddr_.Get();
}
inline void ComputeNode::_internal_set_ipaddr(const std::string& value) {
  ;


  _impl_.ipaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputeNode::_internal_mutable_ipaddr() {
  ;
  return _impl_.ipaddr_.Mutable( GetArenaForAllocation());
}
inline std::string* ComputeNode::release_ipaddr() {
  // @@protoc_insertion_point(field_release:helloworld.ComputeNode.ipaddr)
  return _impl_.ipaddr_.Release();
}
inline void ComputeNode::set_allocated_ipaddr(std::string* value) {
  _impl_.ipaddr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ipaddr_.IsDefault()) {
          _impl_.ipaddr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:helloworld.ComputeNode.ipaddr)
}

// uint32 cores = 3;
inline void ComputeNode::clear_cores() {
  _impl_.cores_ = 0u;
}
inline ::uint32_t ComputeNode::cores() const {
  // @@protoc_insertion_point(field_get:helloworld.ComputeNode.cores)
  return _internal_cores();
}
inline void ComputeNode::set_cores(::uint32_t value) {
  _internal_set_cores(value);
  // @@protoc_insertion_point(field_set:helloworld.ComputeNode.cores)
}
inline ::uint32_t ComputeNode::_internal_cores() const {
  return _impl_.cores_;
}
inline void ComputeNode::_internal_set_cores(::uint32_t value) {
  ;
  _impl_.cores_ = value;
}

// uint64 mem_size = 4;
inline void ComputeNode::clear_mem_size() {
  _impl_.mem_size_ = ::uint64_t{0u};
}
inline ::uint64_t ComputeNode::mem_size() const {
  // @@protoc_insertion_point(field_get:helloworld.ComputeNode.mem_size)
  return _internal_mem_size();
}
inline void ComputeNode::set_mem_size(::uint64_t value) {
  _internal_set_mem_size(value);
  // @@protoc_insertion_point(field_set:helloworld.ComputeNode.mem_size)
}
inline ::uint64_t ComputeNode::_internal_mem_size() const {
  return _impl_.mem_size_;
}
inline void ComputeNode::_internal_set_mem_size(::uint64_t value) {
  ;
  _impl_.mem_size_ = value;
}

// -------------------------------------------------------------------

// Seed

// uint64 id = 1;
inline void Seed::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Seed::id() const {
  // @@protoc_insertion_point(field_get:helloworld.Seed.id)
  return _internal_id();
}
inline void Seed::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:helloworld.Seed.id)
}
inline ::uint64_t Seed::_internal_id() const {
  return _impl_.id_;
}
inline void Seed::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// .helloworld.SeedType seed_type = 2;
inline void Seed::clear_seed_type() {
  _impl_.seed_type_ = 0;
}
inline ::helloworld::SeedType Seed::seed_type() const {
  // @@protoc_insertion_point(field_get:helloworld.Seed.seed_type)
  return _internal_seed_type();
}
inline void Seed::set_seed_type(::helloworld::SeedType value) {
   _internal_set_seed_type(value);
  // @@protoc_insertion_point(field_set:helloworld.Seed.seed_type)
}
inline ::helloworld::SeedType Seed::_internal_seed_type() const {
  return static_cast<::helloworld::SeedType>(_impl_.seed_type_);
}
inline void Seed::_internal_set_seed_type(::helloworld::SeedType value) {
  ;
  _impl_.seed_type_ = value;
}

// uint64 length = 3;
inline void Seed::clear_length() {
  _impl_.length_ = ::uint64_t{0u};
}
inline ::uint64_t Seed::length() const {
  // @@protoc_insertion_point(field_get:helloworld.Seed.length)
  return _internal_length();
}
inline void Seed::set_length(::uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:helloworld.Seed.length)
}
inline ::uint64_t Seed::_internal_length() const {
  return _impl_.length_;
}
inline void Seed::_internal_set_length(::uint64_t value) {
  ;
  _impl_.length_ = value;
}

// uint64 fuzzer_id = 4;
inline void Seed::clear_fuzzer_id() {
  _impl_.fuzzer_id_ = ::uint64_t{0u};
}
inline ::uint64_t Seed::fuzzer_id() const {
  // @@protoc_insertion_point(field_get:helloworld.Seed.fuzzer_id)
  return _internal_fuzzer_id();
}
inline void Seed::set_fuzzer_id(::uint64_t value) {
  _internal_set_fuzzer_id(value);
  // @@protoc_insertion_point(field_set:helloworld.Seed.fuzzer_id)
}
inline ::uint64_t Seed::_internal_fuzzer_id() const {
  return _impl_.fuzzer_id_;
}
inline void Seed::_internal_set_fuzzer_id(::uint64_t value) {
  ;
  _impl_.fuzzer_id_ = value;
}

// string file_path = 5;
inline void Seed::clear_file_path() {
  _impl_.file_path_.ClearToEmpty();
}
inline const std::string& Seed::file_path() const {
  // @@protoc_insertion_point(field_get:helloworld.Seed.file_path)
  return _internal_file_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Seed::set_file_path(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.file_path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:helloworld.Seed.file_path)
}
inline std::string* Seed::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:helloworld.Seed.file_path)
  return _s;
}
inline const std::string& Seed::_internal_file_path() const {
  return _impl_.file_path_.Get();
}
inline void Seed::_internal_set_file_path(const std::string& value) {
  ;


  _impl_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* Seed::_internal_mutable_file_path() {
  ;
  return _impl_.file_path_.Mutable( GetArenaForAllocation());
}
inline std::string* Seed::release_file_path() {
  // @@protoc_insertion_point(field_release:helloworld.Seed.file_path)
  return _impl_.file_path_.Release();
}
inline void Seed::set_allocated_file_path(std::string* value) {
  _impl_.file_path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_path_.IsDefault()) {
          _impl_.file_path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:helloworld.Seed.file_path)
}

// bytes data = 6;
inline void Seed::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Seed::data() const {
  // @@protoc_insertion_point(field_get:helloworld.Seed.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Seed::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:helloworld.Seed.data)
}
inline std::string* Seed::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:helloworld.Seed.data)
  return _s;
}
inline const std::string& Seed::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Seed::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Seed::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* Seed::release_data() {
  // @@protoc_insertion_point(field_release:helloworld.Seed.data)
  return _impl_.data_.Release();
}
inline void Seed::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:helloworld.Seed.data)
}

// -------------------------------------------------------------------

// RegisterRequest

// .helloworld.Fuzzer fuzzer = 1;
inline bool RegisterRequest::has_fuzzer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fuzzer_ != nullptr);
  return value;
}
inline void RegisterRequest::clear_fuzzer() {
  if (_impl_.fuzzer_ != nullptr) _impl_.fuzzer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::helloworld::Fuzzer& RegisterRequest::_internal_fuzzer() const {
  const ::helloworld::Fuzzer* p = _impl_.fuzzer_;
  return p != nullptr ? *p : reinterpret_cast<const ::helloworld::Fuzzer&>(
      ::helloworld::_Fuzzer_default_instance_);
}
inline const ::helloworld::Fuzzer& RegisterRequest::fuzzer() const {
  // @@protoc_insertion_point(field_get:helloworld.RegisterRequest.fuzzer)
  return _internal_fuzzer();
}
inline void RegisterRequest::unsafe_arena_set_allocated_fuzzer(
    ::helloworld::Fuzzer* fuzzer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fuzzer_);
  }
  _impl_.fuzzer_ = fuzzer;
  if (fuzzer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:helloworld.RegisterRequest.fuzzer)
}
inline ::helloworld::Fuzzer* RegisterRequest::release_fuzzer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::helloworld::Fuzzer* temp = _impl_.fuzzer_;
  _impl_.fuzzer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::helloworld::Fuzzer* RegisterRequest::unsafe_arena_release_fuzzer() {
  // @@protoc_insertion_point(field_release:helloworld.RegisterRequest.fuzzer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::helloworld::Fuzzer* temp = _impl_.fuzzer_;
  _impl_.fuzzer_ = nullptr;
  return temp;
}
inline ::helloworld::Fuzzer* RegisterRequest::_internal_mutable_fuzzer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fuzzer_ == nullptr) {
    auto* p = CreateMaybeMessage<::helloworld::Fuzzer>(GetArenaForAllocation());
    _impl_.fuzzer_ = p;
  }
  return _impl_.fuzzer_;
}
inline ::helloworld::Fuzzer* RegisterRequest::mutable_fuzzer() {
  ::helloworld::Fuzzer* _msg = _internal_mutable_fuzzer();
  // @@protoc_insertion_point(field_mutable:helloworld.RegisterRequest.fuzzer)
  return _msg;
}
inline void RegisterRequest::set_allocated_fuzzer(::helloworld::Fuzzer* fuzzer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fuzzer_;
  }
  if (fuzzer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fuzzer);
    if (message_arena != submessage_arena) {
      fuzzer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fuzzer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fuzzer_ = fuzzer;
  // @@protoc_insertion_point(field_set_allocated:helloworld.RegisterRequest.fuzzer)
}

// .helloworld.ComputeNode compute_node = 2;
inline bool RegisterRequest::has_compute_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.compute_node_ != nullptr);
  return value;
}
inline void RegisterRequest::clear_compute_node() {
  if (_impl_.compute_node_ != nullptr) _impl_.compute_node_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::helloworld::ComputeNode& RegisterRequest::_internal_compute_node() const {
  const ::helloworld::ComputeNode* p = _impl_.compute_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::helloworld::ComputeNode&>(
      ::helloworld::_ComputeNode_default_instance_);
}
inline const ::helloworld::ComputeNode& RegisterRequest::compute_node() const {
  // @@protoc_insertion_point(field_get:helloworld.RegisterRequest.compute_node)
  return _internal_compute_node();
}
inline void RegisterRequest::unsafe_arena_set_allocated_compute_node(
    ::helloworld::ComputeNode* compute_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compute_node_);
  }
  _impl_.compute_node_ = compute_node;
  if (compute_node) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:helloworld.RegisterRequest.compute_node)
}
inline ::helloworld::ComputeNode* RegisterRequest::release_compute_node() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::helloworld::ComputeNode* temp = _impl_.compute_node_;
  _impl_.compute_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::helloworld::ComputeNode* RegisterRequest::unsafe_arena_release_compute_node() {
  // @@protoc_insertion_point(field_release:helloworld.RegisterRequest.compute_node)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::helloworld::ComputeNode* temp = _impl_.compute_node_;
  _impl_.compute_node_ = nullptr;
  return temp;
}
inline ::helloworld::ComputeNode* RegisterRequest::_internal_mutable_compute_node() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.compute_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::helloworld::ComputeNode>(GetArenaForAllocation());
    _impl_.compute_node_ = p;
  }
  return _impl_.compute_node_;
}
inline ::helloworld::ComputeNode* RegisterRequest::mutable_compute_node() {
  ::helloworld::ComputeNode* _msg = _internal_mutable_compute_node();
  // @@protoc_insertion_point(field_mutable:helloworld.RegisterRequest.compute_node)
  return _msg;
}
inline void RegisterRequest::set_allocated_compute_node(::helloworld::ComputeNode* compute_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compute_node_;
  }
  if (compute_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compute_node);
    if (message_arena != submessage_arena) {
      compute_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compute_node, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.compute_node_ = compute_node;
  // @@protoc_insertion_point(field_set_allocated:helloworld.RegisterRequest.compute_node)
}

// -------------------------------------------------------------------

// RegisterResponse

// bool success = 1;
inline void RegisterResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RegisterResponse::success() const {
  // @@protoc_insertion_point(field_get:helloworld.RegisterResponse.success)
  return _internal_success();
}
inline void RegisterResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:helloworld.RegisterResponse.success)
}
inline bool RegisterResponse::_internal_success() const {
  return _impl_.success_;
}
inline void RegisterResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// uint64 fuzzer_id = 2;
inline void RegisterResponse::clear_fuzzer_id() {
  _impl_.fuzzer_id_ = ::uint64_t{0u};
}
inline ::uint64_t RegisterResponse::fuzzer_id() const {
  // @@protoc_insertion_point(field_get:helloworld.RegisterResponse.fuzzer_id)
  return _internal_fuzzer_id();
}
inline void RegisterResponse::set_fuzzer_id(::uint64_t value) {
  _internal_set_fuzzer_id(value);
  // @@protoc_insertion_point(field_set:helloworld.RegisterResponse.fuzzer_id)
}
inline ::uint64_t RegisterResponse::_internal_fuzzer_id() const {
  return _impl_.fuzzer_id_;
}
inline void RegisterResponse::_internal_set_fuzzer_id(::uint64_t value) {
  ;
  _impl_.fuzzer_id_ = value;
}

// uint64 compute_node_id = 3;
inline void RegisterResponse::clear_compute_node_id() {
  _impl_.compute_node_id_ = ::uint64_t{0u};
}
inline ::uint64_t RegisterResponse::compute_node_id() const {
  // @@protoc_insertion_point(field_get:helloworld.RegisterResponse.compute_node_id)
  return _internal_compute_node_id();
}
inline void RegisterResponse::set_compute_node_id(::uint64_t value) {
  _internal_set_compute_node_id(value);
  // @@protoc_insertion_point(field_set:helloworld.RegisterResponse.compute_node_id)
}
inline ::uint64_t RegisterResponse::_internal_compute_node_id() const {
  return _impl_.compute_node_id_;
}
inline void RegisterResponse::_internal_set_compute_node_id(::uint64_t value) {
  ;
  _impl_.compute_node_id_ = value;
}

// -------------------------------------------------------------------

// UnregisterRequest

// uint64 fuzzer_id = 1;
inline void UnregisterRequest::clear_fuzzer_id() {
  _impl_.fuzzer_id_ = ::uint64_t{0u};
}
inline ::uint64_t UnregisterRequest::fuzzer_id() const {
  // @@protoc_insertion_point(field_get:helloworld.UnregisterRequest.fuzzer_id)
  return _internal_fuzzer_id();
}
inline void UnregisterRequest::set_fuzzer_id(::uint64_t value) {
  _internal_set_fuzzer_id(value);
  // @@protoc_insertion_point(field_set:helloworld.UnregisterRequest.fuzzer_id)
}
inline ::uint64_t UnregisterRequest::_internal_fuzzer_id() const {
  return _impl_.fuzzer_id_;
}
inline void UnregisterRequest::_internal_set_fuzzer_id(::uint64_t value) {
  ;
  _impl_.fuzzer_id_ = value;
}

// -------------------------------------------------------------------

// UnregisterResponse

// bool success = 1;
inline void UnregisterResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool UnregisterResponse::success() const {
  // @@protoc_insertion_point(field_get:helloworld.UnregisterResponse.success)
  return _internal_success();
}
inline void UnregisterResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:helloworld.UnregisterResponse.success)
}
inline bool UnregisterResponse::_internal_success() const {
  return _impl_.success_;
}
inline void UnregisterResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// HeartbeatRequest

// uint64 fuzzer_id = 1;
inline void HeartbeatRequest::clear_fuzzer_id() {
  _impl_.fuzzer_id_ = ::uint64_t{0u};
}
inline ::uint64_t HeartbeatRequest::fuzzer_id() const {
  // @@protoc_insertion_point(field_get:helloworld.HeartbeatRequest.fuzzer_id)
  return _internal_fuzzer_id();
}
inline void HeartbeatRequest::set_fuzzer_id(::uint64_t value) {
  _internal_set_fuzzer_id(value);
  // @@protoc_insertion_point(field_set:helloworld.HeartbeatRequest.fuzzer_id)
}
inline ::uint64_t HeartbeatRequest::_internal_fuzzer_id() const {
  return _impl_.fuzzer_id_;
}
inline void HeartbeatRequest::_internal_set_fuzzer_id(::uint64_t value) {
  ;
  _impl_.fuzzer_id_ = value;
}

// uint64 exec = 2;
inline void HeartbeatRequest::clear_exec() {
  _impl_.exec_ = ::uint64_t{0u};
}
inline ::uint64_t HeartbeatRequest::exec() const {
  // @@protoc_insertion_point(field_get:helloworld.HeartbeatRequest.exec)
  return _internal_exec();
}
inline void HeartbeatRequest::set_exec(::uint64_t value) {
  _internal_set_exec(value);
  // @@protoc_insertion_point(field_set:helloworld.HeartbeatRequest.exec)
}
inline ::uint64_t HeartbeatRequest::_internal_exec() const {
  return _impl_.exec_;
}
inline void HeartbeatRequest::_internal_set_exec(::uint64_t value) {
  ;
  _impl_.exec_ = value;
}

// uint64 timestamp = 3;
inline void HeartbeatRequest::clear_timestamp() {
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t HeartbeatRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:helloworld.HeartbeatRequest.timestamp)
  return _internal_timestamp();
}
inline void HeartbeatRequest::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:helloworld.HeartbeatRequest.timestamp)
}
inline ::uint64_t HeartbeatRequest::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void HeartbeatRequest::_internal_set_timestamp(::uint64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// HeartbeatResponse

// bool success = 1;
inline void HeartbeatResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool HeartbeatResponse::success() const {
  // @@protoc_insertion_point(field_get:helloworld.HeartbeatResponse.success)
  return _internal_success();
}
inline void HeartbeatResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:helloworld.HeartbeatResponse.success)
}
inline bool HeartbeatResponse::_internal_success() const {
  return _impl_.success_;
}
inline void HeartbeatResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// GetSeedsRequest

// uint64 fuzzer_id = 1;
inline void GetSeedsRequest::clear_fuzzer_id() {
  _impl_.fuzzer_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetSeedsRequest::fuzzer_id() const {
  // @@protoc_insertion_point(field_get:helloworld.GetSeedsRequest.fuzzer_id)
  return _internal_fuzzer_id();
}
inline void GetSeedsRequest::set_fuzzer_id(::uint64_t value) {
  _internal_set_fuzzer_id(value);
  // @@protoc_insertion_point(field_set:helloworld.GetSeedsRequest.fuzzer_id)
}
inline ::uint64_t GetSeedsRequest::_internal_fuzzer_id() const {
  return _impl_.fuzzer_id_;
}
inline void GetSeedsRequest::_internal_set_fuzzer_id(::uint64_t value) {
  ;
  _impl_.fuzzer_id_ = value;
}

// -------------------------------------------------------------------

// GetSeedsResponse

// bool success = 1;
inline void GetSeedsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetSeedsResponse::success() const {
  // @@protoc_insertion_point(field_get:helloworld.GetSeedsResponse.success)
  return _internal_success();
}
inline void GetSeedsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:helloworld.GetSeedsResponse.success)
}
inline bool GetSeedsResponse::_internal_success() const {
  return _impl_.success_;
}
inline void GetSeedsResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// repeated .helloworld.Seed seeds = 2;
inline int GetSeedsResponse::_internal_seeds_size() const {
  return _impl_.seeds_.size();
}
inline int GetSeedsResponse::seeds_size() const {
  return _internal_seeds_size();
}
inline void GetSeedsResponse::clear_seeds() {
  _internal_mutable_seeds()->Clear();
}
inline ::helloworld::Seed* GetSeedsResponse::mutable_seeds(int index) {
  // @@protoc_insertion_point(field_mutable:helloworld.GetSeedsResponse.seeds)
  return _internal_mutable_seeds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::helloworld::Seed >*
GetSeedsResponse::mutable_seeds() {
  // @@protoc_insertion_point(field_mutable_list:helloworld.GetSeedsResponse.seeds)
  return _internal_mutable_seeds();
}
inline const ::helloworld::Seed& GetSeedsResponse::_internal_seeds(int index) const {
  return _internal_seeds().Get(index);
}
inline const ::helloworld::Seed& GetSeedsResponse::seeds(int index) const {
  // @@protoc_insertion_point(field_get:helloworld.GetSeedsResponse.seeds)
  return _internal_seeds(index);
}
inline ::helloworld::Seed* GetSeedsResponse::_internal_add_seeds() {
  return _internal_mutable_seeds()->Add();
}
inline ::helloworld::Seed* GetSeedsResponse::add_seeds() {
  ::helloworld::Seed* _add = _internal_add_seeds();
  // @@protoc_insertion_point(field_add:helloworld.GetSeedsResponse.seeds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::helloworld::Seed >&
GetSeedsResponse::seeds() const {
  // @@protoc_insertion_point(field_list:helloworld.GetSeedsResponse.seeds)
  return _internal_seeds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::helloworld::Seed>&
GetSeedsResponse::_internal_seeds() const {
  return _impl_.seeds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::helloworld::Seed>*
GetSeedsResponse::_internal_mutable_seeds() {
  return &_impl_.seeds_;
}

// -------------------------------------------------------------------

// PutSeedRequest

// uint64 fuzzer_id = 1;
inline void PutSeedRequest::clear_fuzzer_id() {
  _impl_.fuzzer_id_ = ::uint64_t{0u};
}
inline ::uint64_t PutSeedRequest::fuzzer_id() const {
  // @@protoc_insertion_point(field_get:helloworld.PutSeedRequest.fuzzer_id)
  return _internal_fuzzer_id();
}
inline void PutSeedRequest::set_fuzzer_id(::uint64_t value) {
  _internal_set_fuzzer_id(value);
  // @@protoc_insertion_point(field_set:helloworld.PutSeedRequest.fuzzer_id)
}
inline ::uint64_t PutSeedRequest::_internal_fuzzer_id() const {
  return _impl_.fuzzer_id_;
}
inline void PutSeedRequest::_internal_set_fuzzer_id(::uint64_t value) {
  ;
  _impl_.fuzzer_id_ = value;
}

// .helloworld.Seed seed = 2;
inline bool PutSeedRequest::has_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seed_ != nullptr);
  return value;
}
inline void PutSeedRequest::clear_seed() {
  if (_impl_.seed_ != nullptr) _impl_.seed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::helloworld::Seed& PutSeedRequest::_internal_seed() const {
  const ::helloworld::Seed* p = _impl_.seed_;
  return p != nullptr ? *p : reinterpret_cast<const ::helloworld::Seed&>(
      ::helloworld::_Seed_default_instance_);
}
inline const ::helloworld::Seed& PutSeedRequest::seed() const {
  // @@protoc_insertion_point(field_get:helloworld.PutSeedRequest.seed)
  return _internal_seed();
}
inline void PutSeedRequest::unsafe_arena_set_allocated_seed(
    ::helloworld::Seed* seed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seed_);
  }
  _impl_.seed_ = seed;
  if (seed) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:helloworld.PutSeedRequest.seed)
}
inline ::helloworld::Seed* PutSeedRequest::release_seed() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::helloworld::Seed* temp = _impl_.seed_;
  _impl_.seed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::helloworld::Seed* PutSeedRequest::unsafe_arena_release_seed() {
  // @@protoc_insertion_point(field_release:helloworld.PutSeedRequest.seed)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::helloworld::Seed* temp = _impl_.seed_;
  _impl_.seed_ = nullptr;
  return temp;
}
inline ::helloworld::Seed* PutSeedRequest::_internal_mutable_seed() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.seed_ == nullptr) {
    auto* p = CreateMaybeMessage<::helloworld::Seed>(GetArenaForAllocation());
    _impl_.seed_ = p;
  }
  return _impl_.seed_;
}
inline ::helloworld::Seed* PutSeedRequest::mutable_seed() {
  ::helloworld::Seed* _msg = _internal_mutable_seed();
  // @@protoc_insertion_point(field_mutable:helloworld.PutSeedRequest.seed)
  return _msg;
}
inline void PutSeedRequest::set_allocated_seed(::helloworld::Seed* seed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seed_;
  }
  if (seed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seed);
    if (message_arena != submessage_arena) {
      seed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seed, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.seed_ = seed;
  // @@protoc_insertion_point(field_set_allocated:helloworld.PutSeedRequest.seed)
}

// -------------------------------------------------------------------

// PutSeedResponse

// bool success = 1;
inline void PutSeedResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool PutSeedResponse::success() const {
  // @@protoc_insertion_point(field_get:helloworld.PutSeedResponse.success)
  return _internal_success();
}
inline void PutSeedResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:helloworld.PutSeedResponse.success)
}
inline bool PutSeedResponse::_internal_success() const {
  return _impl_.success_;
}
inline void PutSeedResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// PutCoverageRequest

// uint64 fuzzer_id = 1;
inline void PutCoverageRequest::clear_fuzzer_id() {
  _impl_.fuzzer_id_ = ::uint64_t{0u};
}
inline ::uint64_t PutCoverageRequest::fuzzer_id() const {
  // @@protoc_insertion_point(field_get:helloworld.PutCoverageRequest.fuzzer_id)
  return _internal_fuzzer_id();
}
inline void PutCoverageRequest::set_fuzzer_id(::uint64_t value) {
  _internal_set_fuzzer_id(value);
  // @@protoc_insertion_point(field_set:helloworld.PutCoverageRequest.fuzzer_id)
}
inline ::uint64_t PutCoverageRequest::_internal_fuzzer_id() const {
  return _impl_.fuzzer_id_;
}
inline void PutCoverageRequest::_internal_set_fuzzer_id(::uint64_t value) {
  ;
  _impl_.fuzzer_id_ = value;
}

// bytes coverage_data = 2;
inline void PutCoverageRequest::clear_coverage_data() {
  _impl_.coverage_data_.ClearToEmpty();
}
inline const std::string& PutCoverageRequest::coverage_data() const {
  // @@protoc_insertion_point(field_get:helloworld.PutCoverageRequest.coverage_data)
  return _internal_coverage_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PutCoverageRequest::set_coverage_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.coverage_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:helloworld.PutCoverageRequest.coverage_data)
}
inline std::string* PutCoverageRequest::mutable_coverage_data() {
  std::string* _s = _internal_mutable_coverage_data();
  // @@protoc_insertion_point(field_mutable:helloworld.PutCoverageRequest.coverage_data)
  return _s;
}
inline const std::string& PutCoverageRequest::_internal_coverage_data() const {
  return _impl_.coverage_data_.Get();
}
inline void PutCoverageRequest::_internal_set_coverage_data(const std::string& value) {
  ;


  _impl_.coverage_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PutCoverageRequest::_internal_mutable_coverage_data() {
  ;
  return _impl_.coverage_data_.Mutable( GetArenaForAllocation());
}
inline std::string* PutCoverageRequest::release_coverage_data() {
  // @@protoc_insertion_point(field_release:helloworld.PutCoverageRequest.coverage_data)
  return _impl_.coverage_data_.Release();
}
inline void PutCoverageRequest::set_allocated_coverage_data(std::string* value) {
  _impl_.coverage_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.coverage_data_.IsDefault()) {
          _impl_.coverage_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:helloworld.PutCoverageRequest.coverage_data)
}

// -------------------------------------------------------------------

// PutCoverageResponse

// bool success = 1;
inline void PutCoverageResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool PutCoverageResponse::success() const {
  // @@protoc_insertion_point(field_get:helloworld.PutCoverageResponse.success)
  return _internal_success();
}
inline void PutCoverageResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:helloworld.PutCoverageResponse.success)
}
inline bool PutCoverageResponse::_internal_success() const {
  return _impl_.success_;
}
inline void PutCoverageResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// GetCoverageRequest

// uint64 fuzzer_id = 1;
inline void GetCoverageRequest::clear_fuzzer_id() {
  _impl_.fuzzer_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetCoverageRequest::fuzzer_id() const {
  // @@protoc_insertion_point(field_get:helloworld.GetCoverageRequest.fuzzer_id)
  return _internal_fuzzer_id();
}
inline void GetCoverageRequest::set_fuzzer_id(::uint64_t value) {
  _internal_set_fuzzer_id(value);
  // @@protoc_insertion_point(field_set:helloworld.GetCoverageRequest.fuzzer_id)
}
inline ::uint64_t GetCoverageRequest::_internal_fuzzer_id() const {
  return _impl_.fuzzer_id_;
}
inline void GetCoverageRequest::_internal_set_fuzzer_id(::uint64_t value) {
  ;
  _impl_.fuzzer_id_ = value;
}

// -------------------------------------------------------------------

// GetCoverageResponse

// bool success = 1;
inline void GetCoverageResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetCoverageResponse::success() const {
  // @@protoc_insertion_point(field_get:helloworld.GetCoverageResponse.success)
  return _internal_success();
}
inline void GetCoverageResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:helloworld.GetCoverageResponse.success)
}
inline bool GetCoverageResponse::_internal_success() const {
  return _impl_.success_;
}
inline void GetCoverageResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// bytes coverage_data = 2;
inline void GetCoverageResponse::clear_coverage_data() {
  _impl_.coverage_data_.ClearToEmpty();
}
inline const std::string& GetCoverageResponse::coverage_data() const {
  // @@protoc_insertion_point(field_get:helloworld.GetCoverageResponse.coverage_data)
  return _internal_coverage_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetCoverageResponse::set_coverage_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.coverage_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:helloworld.GetCoverageResponse.coverage_data)
}
inline std::string* GetCoverageResponse::mutable_coverage_data() {
  std::string* _s = _internal_mutable_coverage_data();
  // @@protoc_insertion_point(field_mutable:helloworld.GetCoverageResponse.coverage_data)
  return _s;
}
inline const std::string& GetCoverageResponse::_internal_coverage_data() const {
  return _impl_.coverage_data_.Get();
}
inline void GetCoverageResponse::_internal_set_coverage_data(const std::string& value) {
  ;


  _impl_.coverage_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCoverageResponse::_internal_mutable_coverage_data() {
  ;
  return _impl_.coverage_data_.Mutable( GetArenaForAllocation());
}
inline std::string* GetCoverageResponse::release_coverage_data() {
  // @@protoc_insertion_point(field_release:helloworld.GetCoverageResponse.coverage_data)
  return _impl_.coverage_data_.Release();
}
inline void GetCoverageResponse::set_allocated_coverage_data(std::string* value) {
  _impl_.coverage_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.coverage_data_.IsDefault()) {
          _impl_.coverage_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:helloworld.GetCoverageResponse.coverage_data)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace helloworld


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::helloworld::SeedType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::helloworld::SeedType>() {
  return ::helloworld::SeedType_descriptor();
}
template <>
struct is_proto_enum<::helloworld::FuzzerType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::helloworld::FuzzerType>() {
  return ::helloworld::FuzzerType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_helloworld_2eproto_2epb_2eh
